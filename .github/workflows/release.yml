name: Release to npm

on:
  # Fire only after the "Tests" workflow completes
  workflow_run:
    workflows: ["Tests"]   # must match your Tests workflow name exactly
    types: [completed]

permissions:
  contents: read           # default for all jobs; least-privileged

concurrency:
  group: release-${{ github.workflow }}-${{ github.run_id }}
  cancel-in-progress: false

jobs:
  publish:
    if: >
      github.event.workflow_run.conclusion == 'success' &&
      github.event.workflow_run.event == 'push' &&
      github.event.workflow_run.head_branch == 'main' &&
      github.event.workflow_run.head_repository.full_name == github.repository

    runs-on: ubuntu-latest

    permissions:
      contents: read
      id-token: write

    environment:
      name: npm

    steps:
      - name: Checkout (pinned SHA, full history)
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event.workflow_run.head_sha }}
          fetch-depth: 0
          persist-credentials: false

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: 20
          registry-url: https://registry.npmjs.org
          cache: npm

      - name: Install
        run: npm ci

      - name: Test
        run: npm test -- --ci

      - name: Build
        run: npm run build --if-present

      - name: Disable npm lifecycle scripts (safety)
        run: |
          npm config set ignore-scripts true
          echo "npm_config_ignore_scripts=true" >> $GITHUB_ENV

      - name: Read pkg name & version
        id: pkg
        run: |
          echo "name=$(node -p "require('./package.json').name")" >> $GITHUB_OUTPUT
          echo "version=$(node -p "require('./package.json').version")" >> $GITHUB_OUTPUT

      - name: Skip if version already on npm
        id: exists
        run: |
          if npm view "${{ steps.pkg.outputs.name }}@${{ steps.pkg.outputs.version }}" version >/dev/null 2>&1; then
            echo "exists=true" >> $GITHUB_OUTPUT
          else
            echo "exists=false" >> $GITHUB_OUTPUT
          fi

      - name: Publish to npm (with provenance)
        if: steps.exists.outputs.exists == 'false'
        env:
          NODE_AUTH_TOKEN: ${{ secrets.NPM_AUTOMATION_TOKEN_FROM_KOTAPI }}
        run: npm publish --access public --provenance
      
      - name: Announce on Discord (with changelog + README summary)
        if: steps.exists.outputs.exists == 'false'
        env:
          DISCORD_WEBHOOK_URL: ${{ secrets.DISCORD_WEBHOOK_URL }}
          PKG_NAME: ${{ steps.pkg.outputs.name }}
          PKG_VERSION: ${{ steps.pkg.outputs.version }}
          REPO: ${{ github.repository }}
        run: |
          node - <<'NODE'
          const fs = require('fs');
          const https = require('https');

          const webhook = process.env.DISCORD_WEBHOOK_URL;
          const name = process.env.PKG_NAME;
          const version = process.env.PKG_VERSION;
          const repo = process.env.REPO;

          const npmUrl = `https://www.npmjs.com/package/${encodeURIComponent(name)}/v/${version}`;
          const ghUrl = `https://github.com/${repo}`;

          const read = (p) => { try { return fs.readFileSync(p, 'utf8'); } catch { return ''; } };
          const squash = (s='') => s
            .replace(/<!--[\s\S]*?-->/g, '')
            .replace(/\r/g, '')
            .replace(/\n{3,}/g, '\n\n')
            .trim();
          const trunc = (s, n) => (s.length > n ? s.slice(0, n - 1) + 'â€¦' : s);

          // README summary (first paragraph after title/badges)
          let readmeSummary = '';
          const readme = read('README.md');
          if (readme) {
            const lines = readme.split('\n');
            let i = 0;
            while (i < lines.length && (/^\s*#\s/.test(lines[i]) || /!\[.*\]\(.*\)|<img/i.test(lines[i]) || /^\s*$/.test(lines[i]))) i++;
            const para = [];
            for (; i < lines.length && !/^\s*$/.test(lines[i]); i++) para.push(lines[i]);
            readmeSummary = trunc(squash(para.join('\n')), 900); // field limit safe
          }

          // Changelog section for this version
          let changelog = '';
          const raw = read('CHANGELOG.md');
          if (raw) {
            const esc = (v) => v.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
            const pats = [
              new RegExp(`^##\\s*\\[?v?${esc(version)}\\]?\\s*$`, 'mi'),
              new RegExp(`^##\\s*.*\\s+v?${esc(version)}\\s*$`, 'mi'),
            ];
            let start = -1;
            for (const p of pats) { const m = raw.match(p); if (m) { start = m.index; break; } }
            if (start >= 0) {
              const tail = raw.slice(start);
              const next = tail.search(/^##\s+/m);
              const section = (next > 0 ? tail.slice(0, next) : tail).replace(/^##.*$/m, '');
              changelog = trunc(squash(section), 3600); // embed desc limit
            } else {
              // fallback: top-most section
              const parts = raw.split(/^##\s+/m);
              if (parts[1]) changelog = trunc(squash(parts[1]), 3600);
            }
          }

          const body = {
            username: "Rad UI Release Bot",
            // avatar_url: "https://your.cdn/rad-ui-logo.png", // optional
            embeds: [{
              title: `Released ${name} ${version} ðŸŽ‰`,
              url: npmUrl,
              description: changelog || "Changelog is available in the repo.",
              fields: [
                ...(readmeSummary ? [{ name: "Summary", value: readmeSummary, inline: false }] : []),
                { name: "npm", value: `[${name}@${version}](${npmUrl})`, inline: true },
                { name: "GitHub", value: ghUrl, inline: true }
              ],
              timestamp: new Date().toISOString()
            }]
          };

          const data = JSON.stringify(body);
          const u = new URL(webhook);
          const req = https.request(
            { 
              hostname: u.hostname, 
              path: u.pathname + u.search, 
              method: 'POST',
              headers: { 
                'Content-Type': 'application/json', 
                'Content-Length': Buffer.byteLength(data) 
              } 
            },
            res => { 
              res.resume(); 
              res.on('end', () => process.exit(res.statusCode < 300 ? 0 : 1)); 
            }
          );
          req.on('error', err => { console.error(err); process.exit(1); });
          req.write(data); req.end();
          NODE

